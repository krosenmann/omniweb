===================================================
SphinxWEB. Sphinx-based literate programming system
===================================================
**EXTREMELY WIP!**
Not recommended for use!


Dispensable preface
===================

Literate programming and me
---------------------------

Metamarkup specification
========================

SphinxWEB builded on top of the ReStructuredText (sphinx
extension).
List of additional markups:

**@@@@** 
  double at* Escaping @@ symbol. For example, if U wanna write
  *an email address in document then you need to write double at symbol:
  **krosenmann@@@@example.com* and on weaving it will looks normally:
  **krosenmann@@example.com*. This happens because @@ is the main direct
  *symbol I use for metaformatting commands.

**@@<Chunk name@@>**
  name of code chunk. This string will be replaced with
  code on tangling. On weaving it will be replaced with link to chunk
  definition.
  ReST formatting in chunk name is supported.

**@@<Chunk name@@> = language** 
  Definition of the code chunk on the *language* programming
  language. Language name uses on weaving (to create `.. code ::
  language` structures in final document.

**@@<Chunk name@@> =+ language** 
  Extension of the already defined code chunk. For file chunks works
  exactly the same.

**@@iftangle**/ **@@endif** 
  Only tangle reads this block. Weave ignores anything between *@@iftange*
  and *@@endif*.

**@@ifweave** / **@@endif** 
  Only weave reads this block. Tangle
  ignores it.

**@@skip** / **@@endskip**
  Skip code between commands both for weaving and tangling
  


Tangling: The `sph-tangle` Program
==================================
Major additional markup commands over ReST are *file chunks* and *code
chunks*. Each starts with the name of the code chunk in special
bracketing sequences, and continues until a line with single @ on it.

I stole it from the magnificent TexiWeb Jr. project.

* @@(filename@@)
* @@<chunkname@@>

All of code blocks ends with the signle  ``@@`` character.

Getting Started
---------------
Tangler is the single file program. As a usual python programm it
contains schebang, copyright, import, code and entry point sections

@(sph-tangle@) = python
@<Python3 shebang@>
@<Copyright@>
@<Tangle imports@>
@<Common ``sph-tangle`` code chunks@>
@<``sph-tangle`` Entery point@>
@

In this project we haven't any python special magic and I think any
python3 version supported.

@<Python3 shebang@> = python
#!/usr/bin/env python3
@

Other chunks will be described later in conceptual order. Any imports
will be defined only at the were we needs.


.. _parsing-protocol:

Parsing protocol
----------------
Main logic of the document parsing is very simple:
We have pipe of functions for every single line, and all functions
tries to  parse the line. If parser function can't parse the string,
function pass the line to next parser.

Every function takes at least stream object and position object. Also
every parser function returns ``(stream, position)`` tuple.
Stream object
  File object, actually.

Position object
  Structure wich contains full coordinate information: file name and
  line number.

@<Tangle imports@> =+ python
from dataclasses import dataclass
@

@<Position object@> = python
@dataclass
class Position:
    line: int
    filename: str
@

Sections exclusive for tangling.
-------------------------------------------

Some operations or sections can be exclusive for operations. As an
example, examples itself can be specific for weaving. That's why we
need operation specific bracketing mechanism.

Nested bracketing are **not** supported.

``@@ifweave`` or ``@@iftangle``
  Start of exculsive block

``@@endif``
  End of exclusive block

``@@skip``
  Ignore block both in weave and tangle

``@@endskip``
  End of ``@@skip`` block

@<Common ``sph-tangle`` code chunks@> =+ python
@<Handle ``@@ifweave`` and ``@@skip`` for ``sph-tangle``@>
@

Skipping has the same logic and no difference what type of brackets
was used. We define generic function and reuse it with
:func_:`partial` for every concrete case.

@<Tangle imports@> =+ python
from functools import partial
@

@<Handle ``@@ifweave`` and ``@@skip`` for ``sph-tangle``@> = python
@<Skip block in brackets@>
skip_if_weave = partial(skip_block_in_brackets, initial='@ifweave', end='@endif')
skip_if_skip = partial(skip_block_in_brackets, initial='@skip', end='@endskip')
@

Generic skipping very usefull and we will use it in ``sph-weave`` too.
It's regular parsing function and as any others follows the parsing
protocol. :ref:`parsing-protocol`

@<Skip block in brackets@> = python
def skip_block_in_brackets(line, stream, position, initial, end):
    """
    Skip lines between ``@@ifweave`` and ``@@endif``
    :param line: last string
    :param stream: Text IO stream (file-object)
    :param position: ``Position`` object
    :param initial: begin of skipped block.
    :param end: end of skipped block.
    """
    if line.strip(' ') == initial:
        while line.strip(' ') != end:
            line = stream.readline()
            position.line += 1
        line = stream.readline()
    return (line, stream, position)
@


Reading chunks
----------------------

On tangling, we're not interested in language of code block. Language
name used only for weaving and for syntax highlighting in code
editor.

So, to detect the code block, we look only for code block brackets.

@<Chunk regexps@> = python
FILE_CHUNK_RE = re.compile(r"^\s*@\(([^\)]+)@\)\s*=")
REGULAR_CHUNK_RE = re.compile(r"^\s*@<([^>]+)@>\s*=")
END_OF_CHUNK = re.compile(r"^\s*@\s*$")
@

@<Tangle imports@> =+ python
import re
@

Here appears ``THECODE``. This is the the dictionary wich contains
every chunk of code before. We will talk about it later.

@<Read the code chunk@> =+ python
def read_code_chunk(line, stream, position):
    chunk_match = FILE_CHUNK_RE.match(line) or REGULAR_CHUNK_RE.match(line)
    if chunk_match is not None:
        chunkname = chunk_match.group(1)
        @<Debug helpers@>
        while reading_chunk_mode:
            line = stream.readline()
            if END_OF_CHUNK.match(line) is not None:
                # Get the next line for pass to next parser
                # We don't need line with single @
                line = stream.readline()
                break
            THECODE[chunkname].append(line)
    return (line, stream, position)
@

Debug helpers
-------------

For debug, tagle inserts coordinates for chunk when followed code was
produced. Code coordinate  is the line number in original WEB document
and the name of chunk.

@<Debug helpers@> = python
THECODE[chunkname].append("{} defined in file {}, line: {}".format(
    chunkname,
    stream.name,
    position.line,
))
@


Escaping @@
-----------
@@ (double "at") used for escaping symbol ``@@`` itself. This code
rule is universal for content and for code both. For translation it's
very simple: if we see it then we split it.

@<escape the @@ @> = python
def escape_the_at(line):
    return line.replace('@@', '@')
@



External tools
==============

Emacs sphinxweb polymode
------------------------

Emacs yasnippet snippets
------------------------

