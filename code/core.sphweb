====================
SphinxWEB Main parts
====================

Chunk Representation and operations
===================================

Chunk
-----

The parsed source represents a group of interconnected trees. Chunk is
a leaf of this tree. File chunks use as roots for every code tree.

Alongside the name and code, every chunk structure connected with
usage and all used chunks in its code. One chunk can be used in
different tangled files, that's why trees possibly cross-connected.

Also, every chank has a link to the place of its definition. Link has
two parts file path and line number. This information used both by tangling and
weaving.

``language`` is the field used by weaver. Also, language in chunk
definition can be used for providing syntax highlighting in your text
editor. See @external-doc{external-tools/poly-sphinxweb} for GNU Emacs example.

All chunks stored in one of two hash tables: one for file chunks and
another for regular chunks. Names used as the string keys.

Chunks itself doesn't know anything about their type. All depends
on storage only.


@<Chunk definition and creation@> = lisp
(defstruct chunk
  name
  code
  link
  appears-in
  contains
  language
  file)

(defparameter *file-chunks* (make-hash-table :test 'equal))

(defparameter *chunks* (make-hash-table :test 'equal))
@

Operations
----------

There's two possible operations for chunk.
Definition (``=``) and expansion (``=+``).

Definition just creates chunk

@<Chunk operations@> = lisp
(defun !create-chunk (fields is-file?)
  (let ((new-chunk (apply #'make-chunk fields))
        (storage (if is-file?
                     *file-chunks*
                     *chunks*)))
    (setf (gethash (chunk-name new-chunk) storage) new-chunk)))

@

Expansion appends chunk structure to existent with the same
name. Actually, expansion is the parametrized increment function for structures.

@<Chunk operations@> =+ lisp

(defun !append-selected-fields (to from &rest field-list) 
  (dolist (field field-list)
     (setf (slot-value to field) (append (slot-value to field) (slot-value from field))))
  to)


(defun !append-chunk (fields is-file?)
  (let* ((appendix (apply #'make-chunk fields))
         (storage (if is-file?
                      *file-chunks*
                      *chunks*))
         (for-extension (gethash (chunk-name appendix) storage))
         (initial-file (chunk-file for-extension))
         (appendix-file (chunk-file appendix)))
    (when (not (equal initial-file appendix-file))
      (error (format 'nil "Multifile expansion! Chunk defined in ~A but expands in ~A"
                     initial-file appendix-file)))
    (!append-selected-fields for-extension appendix 'code 'link)))

@

That's all. This is all operations what we need for chunks
itself. Any other chunk function in the system is about parsing or producing
result.

Parsing
=======

Core point of parsing: read all given source files and create
structures for chunks.

@<Parsing@> = lisp
@<File operations@>
@<Line parsing@>
@<Building a tree@>
@

Reading a file
--------------

@<File operations@> = lisp
(defun read-this-file ()
  (uiop:read-file-lines "core.sphweb"))
@

Fixing chunk headers
--------------------

TBD

@<File operations@> =+ lisp

@


Line parsing
------------

Line parsing utility reads file line by line and creates lisp
respresentation of every readed chunk.

@<Chunk regexps@> = lisp
(defparameter *chunk-name* "^@<([^>]+)@>")
(defparameter *file-name* "^@\\(([^)]+)@\\)")
(defparameter *operation* "\\s*(=\\+?)\\s*")
(defparameter *language* "([\\S]+)\\s*$")
(defconstant +end-of-chunk+ "^@\\s*$")

(defparameter *chunk-definition* 
  (concatenate 'string *chunk-name* *operation* *language*))
(defparameter *filechunk-definition* 
  (concatenate 'string *file-name* *operation* *language*))
@

First, we looking for chunk head in the code. If header matched then
starts chunk construction mode. Every line until end of chunk appends
to ``code`` field in the chunk structure.

@<Line parsing@> = lisp
(defun header? (line)
  (ppcre:register-groups-bind (name op language)
      (*chunk-definition* line)
    (list 
     (if (equal op "=") '!create-chunk '!append-chunk)
     :name name
     :language language))
    )

(defun eoc? (line)
  (ppcre:scan +end-of-chunk+ line))

(defun extract-chunks (lines)
  (let ((chunk-mode? 'nil)
        (buff 'nil)
        (current-chunk 'nil))
    (dolist (line lines)
      (let ((header (header? line))
             (eoc (eoc? line)))
        (cond
          (eoc (progn
                 (apply (car current-chunk)
                        (list (append (cdr current-chunk)
                                      (list :code buff :file "core.sphweb"))
                              'nil))
                 (setf chunk-mode? 'nil)
                 (setf buff '())))
          (header (progn
                    (setf current-chunk header)
                    (setf chunk-mode? t)
                    (format t "Header: ~A ~%" header)
                    ))
          (chunk-mode? (setf buff (append buff (list line)))))
          ))
      ))
@

